# 常用设计模式
> 设计模式使用时，会比较纠结使用`interface`接口还是`abstract class`抽象类来定义接口实现，个人观点是：`如果实现的功能需要调用相同的方法，那么使用抽象类，否则使用接口；因为抽象类允许实现方法，而接口不行`   
       
## 1、工厂模式
>使用统一的类方法来构造所有对象，方便管理所有对象。
>具体实现：

```php
<?php

class Person
{
	public function eat()
	{
		echo 'EAT', PHP_EOL;
	}
}

class Factory
{
	/**传入类名
	 *
	 * @param string $class
	 */
	public static function make($class)
	{
		return new $class;
	}
}

Factory::make(Person::class)->eat();//EAT
````

## 2、单例模式
>在创建类实例之前会先判断该类实例是否已经存在，如何已存在则返回。
>实现步骤：

    1、私有化构造方法
    2、私有化__clone魔术方法
    3、声明私有静态属性，用来保存本类实例
    4、创建静态类方法如getInstance专门获取该类实例；获取之前先判断类实例是否已经存在，存在则返回。
    
```php
class Sms
{
	/**
	 * @var \Sms
	 */
	private static $instance;

	/**私有化构造方法
	 * Sms constructor.
	 */
	private function __construct()
	{
	}

	/**
	 *私有化克隆方法
	 */
	private function __clone()
	{
		// TODO: Implement __clone() method.
	}

	/**获取本类实例对象
	 *
	 * @return \Sms
	 */
	public static function getInstance()
	{
		if (!(self::$instance instanceof self))
		{
			self::$instance = new self();
		}
		return self::$instance;
	}

	public function sendSms()
	{
		echo 'Send sms';
	}
}

Sms::getInstance()->sendSms();//Send sms
``` 
## 3、注册树模式
>工厂单例模式

## 4、适配器模式
>为了实现同一种功能，定义一个统一接口，然后由不同的方式来实现该接口。
       
## 5、观察者模式
>当事件发生时，将该事件通知该事件感兴趣的观察者。
       
## 6、策略模式
>根据不同的条件，使用不同的策略。

## 7、装饰器模式
>

## 8、控制反转（依赖注入）
>